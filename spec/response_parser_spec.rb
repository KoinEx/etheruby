require_relative '../lib/etheruby/response_parser'

describe Etheruby::ResponseParser do

  it 'works on case 1' do
    data = '0x00000000000000000000000000000002200000000000000000000000000000000000000000000000000000000000000880000000000000000000000000000000'
    sign = { case1: 'fixed128x128[2]'}
    resp = described_class.new(sign, data).parse
    expect(resp.case1).to eq([2.125, 8.5])
  end

  it 'works on case 2' do
    data = '0x00000000000000000000000000000000000000000000000000000000000000450000000000000000000000000000000000000000000000000000000000000001'
    sign = { position: :uint32, is_upper: :bool }
    resp = described_class.new(sign, data).parse
    expect(resp.position).to eq(69)
    expect(resp.is_upper).to eq(true)
  end

  it 'works on case 3' do
    data = '0x0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000000464617665000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000003'
    sign = {name: :bytes, is_here: :bool, my_array: 'uint256[]'}
    resp = described_class.new(sign, data).parse
    expect(resp.name).to eq("dave".codepoints)
    expect(resp.is_here).to eq(true)
    expect(resp.my_array).to eq([1,2,3])
  end

  it 'works on case 4' do
    data = "0x00000000000000000000000000000000000000000000000000000000000001230000000000000000000000000000000000000000000000000000000000000080313233343536373839300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000004560000000000000000000000000000000000000000000000000000000000000789000000000000000000000000000000000000000000000000000000000000000d48656c6c6f2c20776f726c642100000000000000000000000000000000000000"
    sign = { arg1: :uint256, arg2: 'uint32[]', arg3: :bytes10, arg4: :bytes }
    resp = described_class.new(sign, data).parse
    expect(resp.arg1).to eq(0x123)
    expect(resp.arg2).to eq([0x456, 0x789])
    expect(resp.arg3).to eq("1234567890".codepoints)
    expect(resp.arg4).to eq("Hello, world!".codepoints)
  end

  it 'works on case 5' do
    data = "0x0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001"
    sign = {arg1: 'uint256[]'}
    resp = described_class.new(sign, data).parse
    expect(resp.arg1).to eq([0,1])
  end

end
